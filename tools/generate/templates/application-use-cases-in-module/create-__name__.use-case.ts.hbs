import { ConflictException, Injectable } from '@nestjs/common';
import { Create__Name__Dto } from '../dtos/create-__name__.dto';
import { __Name__Entity } from '@domain/entities/__name__.entity';
import { __Name__Repository } from '@domain/repositories/__name__.repository';

// Imports Condicionais (MANTENHA COMO COMENTADO OU REMOVA, seu gerador insere se precisar)
// import { EncryptionUtil } from '@infra/common/utils/encryption.util'; 
// import { RoleEnum } from '@domain/constants/roles.enum';
// import { RoleRepository } from '@domain/repositories/role.repository'; 

@Injectable()
export class Create__Name__UseCase {
  constructor(
    private readonly __name__Repository: __Name__Repository,
    // TODO: O gerador pode adicionar outras injeções aqui (Ex: private readonly roleRepository: RoleRepository).
  ) {}

  async execute(
    dto: Create__Name__Dto,
    // TODO: O gerador pode adicionar argumentos aqui (Ex: assignRole?: RoleEnum).
  ): Promise<__Name__Entity> {

    // TODO: Lógica de validação de negócio específica para '__Name__'.
    // Ex: Verificar se um campo único já existe.
    // const uniqueFieldValue = dto.someUniqueField;
    // const existing__name__ = await this.__name__Repository.findByUniqueField(uniqueFieldValue);
    // if (existing__name__) {
    //   throw new ConflictException(`__Name__ com este valor único já existe.`);
    // }

    // TODO: Pré-processamento de dados (hash de senhas, buscar roles, etc.).
    // Ex: let hashedPassword = await EncryptionUtil.hash(dto.password);

    // Cria a entidade
    const new__name__ = new __Name__Entity();
    // A BaseRepository já cuidará do ID e timestamps.
    // TODO: Mapear propriedades do DTO para a entidade.
    // Ex: new__name__.name = dto.name;
    // Ex: new__name__.email = dto.email;
    // Ex: if (hashedPassword) new__name__.passwordHash = hashedPassword;

    return await this.__name__Repository.save(new__name__);
  }
}